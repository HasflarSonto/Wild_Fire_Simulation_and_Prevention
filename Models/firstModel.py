import numpy as np
import random

#inputs are:
# 1) 2d matrix w/ (x, y, type of material, current burn probability)
# 2) wind tuple

# Wind direction influence as a tuple (x, y) and severity
WIND_VECTOR = np.array([2, 3])
WIND_UNIT = WIND_VECTOR / np.linalg.norm(WIND_VECTOR)
#severity will just be calculated on the norm of (x,y)

def compute_wind_severity(direction_vector):
    direction_magnitude = np.linalg.norm(direction_vector)
    
    if direction_magnitude == 0:
        return 0  # No wind influence if the direction vector is zero
    
    direction_unit = direction_vector / direction_magnitude
    
    severity = np.dot(WIND_UNIT, direction_unit)
    return severity


MATERIALS = {
    -1: 0.0, #Burnt
    0: 0.5,  # Brush
    1: 0.4,  # Long Needle Litter
    2: 0.3,  # Short Needle Litter 
    3: 0.2   # Short Grass ? (not specified in the thing)
}


material_timer = {

    0.5: 10,  # Brush
    0.4: 10,  # Long Needle Litter
    0.3: 10,  # Short Needle Litter
    0.2: 10   # Short Grass

}


# Initialize a grid with materials
grid = np.array([[0.3, 0.4, 0.4, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.4, 0.4, 0.5, 0.5, 0.5, 0.5, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4], [0.3, 0.3, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.4, 0.5, 0.5, 0.5, 0.5, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.5, 0.4], [0.3, 0.3, 0.5, 0.4, 0.4, 0.4, 0.3, 0.4, 0.4, 0.5, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.4, 0.5, 0.5, 0.5, 0.4, 0.5, 0.4, 0.5, 0.5, 0.5, 0.4], [0.3, 0.4, 0.5, 0.3, 0.3, 0.3, 0.4, 0.3, 0.3, 0.4, 0.5, 0.4, 0.3, 0.4, 0.4, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.5, 0.5, 0.4, 0.5, 0.5, 0.4, 0.3, 0.5, 0.5, 0.5], [0.4, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.4, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.5, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4], [0.3, 0.3, 0.5, 0.5, 0.5, 0.5, 0.3, 0.3, 0.5, 0.5, 0.5, 0.5, 0.4, 0.5, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4], [0.4, 0.4, 0.4, 0.5, 0.4, 0.4, 0.4, 0.3, 0.3, 0.5, 0.5, 0.5, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4], [0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.5, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5], [0.3, 0.4, 0.4, 0.4, 0.3, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.4], [0.4, 0.5, 0.5, 0.4, 0.4, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.4, 0.3, 0.3, 0.3, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.3, 0.5, 0.5], [0.3, 0.4, 0.4, 0.4, 0.5, 0.5, 0.4, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.5, 0.3], [0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.5, 0.5, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.4, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.3, 0.3, 0.3, 0.4, 0.4, 0.5, 0.4], [0.3, 0.4, 0.5, 0.3, 0.4, 0.4, 0.5, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.5, 0.3], [0.3, 0.3, 0.4, 0.3, 0.5, 0.5, 0.5, 0.4, 0.4, 0.4, 0.4, 0.5, 0.5, 0.5, 0.4, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3], [0.3, 0.3, 0.3, 0.4, 0.4, 0.5, 0.4, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.4, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.3], [0.3, 0.3, 0.3, 0.4, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.4, 0.3, 0.3, 0.3, 0.4, 0.5, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.3, 0.3, 0.4], [0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3], [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.5, 0.3], [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4, 0.3], [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.3, 0.4, 0.4, 0.3, 0.3, 0.4, 0.3, 0.4, 0.4, 0.4, 0.4], [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4], [0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3], [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.4, 0.3, 0.3, 0.3, 0.2, 0.2, 0.2, 0.2, 0.3, 0.2, 0.2, 0.2, 0.3, 0.3, 0.3, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.3, 0.3, 0.3, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.2, 0.2, 0.3, 0.4, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.5, 0.2, 0.2, 0.2, 0.3, 0.4, 0.2, 0.2, 0.2, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.3, 0.3, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.4, 0.4, 0.4, 0.4, 0.3, 0.4, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.4, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3], [0.3, 0.2, 0.2, 0.4, 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.2, 0.2, 0.4, 0.2, 0.2, 0.5, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3], [0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.4, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.3, 0.4, 0.4, 0.4, 0.2, 0.2, 0.5, 0.2, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3], [0.2, 0.2, 0.2, 0.5, 0.4, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.4, 0.4, 0.4, 0.3, 0.2, 0.2, 0.2, 0.2, 0.2, 0.3, 0.3, 0.3, 0.3, 0.3]]
)


#calculate the wind based on the vector






#should have values in a double format



# Start fire at a random location
#timer is going to be a dictionary with key (i,j) and value of the time set

def find_fire_start(wind):
    row = 0 if wind[1] < 0 else len(grid) - 1
    col = len(grid[0]) - 1 if wind[0] < 0 else 0
    return row, col

row, col = find_fire_start(WIND_VECTOR)
timer = dict()
timer[(row, col)] = material_timer[grid[row][col]]
grid[row, col] = 1


#right now only calculates this value based on wind and material
def calculate_fire_probability(material, direction_vector):
    prob = material
    severity = compute_wind_severity(direction_vector)
    if severity < 0:
        return 0
    return prob * severity

#should I take in the previous probability? 
#probably nice 



def spread_fire(fire_grid):
    new_fire_grid = fire_grid.copy()
    rows, cols = grid.shape
    for i in range(rows):
        for j in range(cols):
            if new_fire_grid[i, j] == 1:  # If the tile is on fire
                timer[(i,j)] -= 1
                if timer[(i,j)] <= 0:
                    new_fire_grid[i][j] = -1
                    continue

                for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # Check all neighbors
                    ni, nj = i + di, j + dj
                    if 0 <= ni < rows and 0 <= nj < cols and new_fire_grid[ni, nj] > 0 and new_fire_grid[ni,nj] < 1:
                        material = grid[ni, nj]
                        newProb = calculate_fire_probability(material, (-di,dj))
                        if random.random() < newProb:
                            new_fire_grid[ni, nj] = 1  # Tile catches fire
                            timer[(ni,nj)] = material_timer[material]
    return new_fire_grid

# Run simulation for a few steps
res = []
fire_grid = grid
for step in range(30):
    print(f"Step {step+1}:")
    fire_grid = spread_fire(fire_grid)
    res.append(fire_grid)
    print(fire_grid)
    print()

#res is a matrix of matricies


def save_matrix_to_txt(matrix, filename):
    """Saves a matrix to a text file, with each row on a new line and elements space-separated."""
    with open(filename, 'w') as file:
        for row in matrix:
            file.write(' '.join(map(str, row)) + '\n')

# Example usage:

file_path = "matrix.txt"
save_matrix_to_txt(res, file_path)
